mod src.player;

import src.lib.sdl;
import src.resource;
import src.drawable;
import src.collision;
import src.movement;

import core.io;
import std.list;
import std.math;

struct
| name : string
| body : Drawable
| eyes : Drawable
| speedX : i32
| speedY : i32
| isJumping : bool
| jumpsCount : i32
| linearMovement : LinearMovement
| parabolicMovement : ParabolicMovement
 -> Player;

private
{
    imut gHorizontalSpeed = 1;
    imut gVerticalSpeed = 1;
    imut gMaxJumpsCount = 2;
}

def createPlayer (name : string, const posX : i32, const posY : i32, resType : ResourceType) -> Player
{
    let resManager = getResourcesManager ();
    let bodyRes = resManager.getResource (resType);
    let eyesRes = resManager.getResource (ResourceType::Eyes);
    let body = Drawable { Position { posX, posY }, bodyRes };
    let eyes = Drawable { Position { posX + 4, posY + 4 }, eyesRes };
    let linearMovement = createLinearMovement (posX, posY);
    return Player { name, body, eyes, 0, 0, false, 0, linearMovement, ParabolicMovement::init };
}

def getDrawables (ref player : Player) -> mut List!(p!Drawable)
{
    let res = list!(p!Drawable) ();
    res.push (&(player.body));
    res.push (&(player.eyes));
    return res;
}

def jump (ref player : Player)
{
    if (player.jumpsCount < gMaxJumpsCount)
    {
        player.isJumping = true;
        if (player.speedX == 0)
            player.parabolicMovement.start (player.body.pos.x, player.body.pos.y, gVerticalSpeed, cast!f32 (Math::PI / 2));
        else
        {
            player.parabolicMovement.start (player.body.pos.x, player.body.pos.y, player.linearMovement.speedX, cast!f32 (Math::PI / 3));
        }
        player.jumpsCount++;
    }
}

def stopJumping (ref player : Player)
{
    player.isJumping = false;
    player.linearMovement.start (player.body.pos.x, player.body.pos.y);    
}

def fall (ref player : Player)
{
    let colManager = getCollisionManager ();
    if (colManager.canGoDown (player, gVerticalSpeed))
    {
        player.linearMovement.move (gVerticalSpeed, MoveDirection::Down);
    }
    else
    {
        player.jumpsCount = 0;
        player.linearMovement.stop (MoveDirection::Down);
    }
}

def goRight (ref player : Player)
{
    if (!player.isJumping)
    {
        let colManager = getCollisionManager ();
        if (colManager.canGoRight (player, gHorizontalSpeed))
            player.linearMovement.move (gHorizontalSpeed, MoveDirection::Right);
        else
            player.linearMovement.stop (MoveDirection::Right);
    }
    else 
    {
    //     if (player.speedX == 0)
    //     {
    //         player.parabolicMovement.horizontalForce += 0.1f;
    //     }
    //     else if (player.speedX < 0)
    //     {
    //         if (player.parabolicMovement.horizontalForce < 2)
    //             player.parabolicMovement.horizontalForce += 0.01f;
    //     }
    //     else if (player.speedX > 0)
    //     {
    //         if (player.parabolicMovement.horizontalForce > 0)
    //             player.parabolicMovement.horizontalForce -= 0.01f;
    //     }
    }
}

def goLeft (ref player : Player)
{
    if (!player.isJumping)
    {
        let colManager = getCollisionManager ();
        if (colManager.canGoLeft (player, gHorizontalSpeed))
            player.linearMovement.move (gHorizontalSpeed, MoveDirection::Left);
        else
            player.linearMovement.stop (MoveDirection::Left);
    }
    else
    {
        // if (player.speedX == 0)
        // {
        //     player.parabolicMovement.horizontalForce += 0.1f;
        // }
        // else if (player.speedX > 0)
        // {
        //     if (player.parabolicMovement.horizontalForce < 2)
        //         player.parabolicMovement.horizontalForce += 0.01f;
        // }
        // else if (player.speedX < 0)
        // {
        //     if (player.parabolicMovement.horizontalForce > 0)
        //         player.parabolicMovement.horizontalForce -= 0.01f;
        // }
    }
}

def goTo (ref player : Player, posX : i32, posY : i32)
{
    player.body.pos.x = posX;
    player.body.pos.y = posY;
    player.eyes.pos.x = posX + 4;
    player.eyes.pos.y = posY + 4;
}

def passRow (ref player : Player)
{    
    if (!player.isJumping)
    {
        let (x, y) = player.linearMovement.nextPosition ();
        player.speedX = x - player.body.pos.x;
        player.speedY = y - player.body.pos.y;
        player.goTo (x, y);

        player.fall ();
    }
    else
    {
        player.passRowJump ();
    }
}

def passRowJump (ref player : Player)
{
    let (x, y) = player.parabolicMovement.nextPosition ();
    let diffX = x - player.body.pos.x;
    let diffY = y - player.body.pos.y;
    
    let colManager = getCollisionManager ();
    let collided = false;
    
    // If we are going to the right...
    if (diffX > 0)
    {
        if (!colManager.canGoRight (player, diffX))
        {
            player.stopJumping ();
            collided = true;
        }
    }
    // If we are going to the left...
    else if (diffX < 0)
    {
        if (!colManager.canGoLeft (player, -diffX))
        {
            player.stopJumping ();
            collided = true;
        }
    }

    // If we are going down...
    if (diffY > 0)
    {
        if (!colManager.canGoDown (player, diffY))
        {
            player.stopJumping ();
            collided = true;
        }
    }
    // If we are going up...
    else if (diffY < 0)
    {
        if (!colManager.canGoUp (player, -diffY))
        {
            player.stopJumping ();
            collided = true;
        }
    }

    player.speedX = diffX;
    player.speedY = diffY;
    
    if (!collided)
        player.goTo (x, y);
}
